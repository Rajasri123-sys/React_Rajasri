READ
# React_Rajasri

React is a JavaScript library for building user interfaces.
React is used to build single-page applications.
React allows us to create reusable UI components.

import { createRoot } from 'react-dom/client';
function Hello() {
  return (
    <h1>Hello World!</h1>
  );
}
createRoot(document.getElementById('root')).render(
  <Hello />
);

Before you continue you should have a basic understanding of the following:
HTML
CSS
JavaScript

React is a front-end JavaScript library.
React was developed by the Facebook Software Engineer Jordan Walke.
React is also known as React.js or ReactJS.
React is a tool for building UI components.

React creates a VIRTUAL DOM in memory.
Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.
React only changes what needs to be changed!
React finds out what changes have been made, and changes only what needs to be changed.
You will learn the various aspects of how React does this in the rest of this tutorial.

Setting up a React Environment
First, make sure you have Node.js installed. You can check by running this in your terminal:

node -v
If Node.js is installed, you will get a result with the version number:

v22.15.0
If not, you will need to install Node.js.

Install a Build Tool (Vite)
When you have Node.js installed, you can start creating a React application by choosing a build tool.

We will use the Vite build tool in this tutorial.

Run this command to install Vite:

npm install -g create-vite
If the installation was a success, you will get a result like this:

added 1 package in 649ms
Create a React Application
Run this command to create a React application named my-react-app:

npm create vite@latest my-react-app -- --template react
If you get this message, just press y and press Enter to continue:

Need to install the following packages:
create-vite@6.5.0
Ok to proceed? (y)
If the creation was a success, you will get a result like this:


> npx
> create-vite my-react-app --template react

|
o  Scaffolding project in C:\Users\stale\my-react-app...
|
—  Done. Now run:

  cd my-react-app
  npm install
  npm run dev
Install Dependencies
As the result above suggests, navigate to your new react application directory:

cd my-react-app
And run this command to install dependencies:

npm install
Which will result in this:

added 154 packages, and audited 155 packages in 8s

33 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Run the React Application
Now you are ready to run your first real React application!

Run this command to run the React application my-react-app:

npm run dev
Which will result in this:

VITE v6.3.5  ready in 217 ms

➜ Local: http://localhost:5173/
➜ Network: use --host to expose
➜ press h + enter to show help
A new browser window will pop up with your newly created React App! If not, open your browser and type localhost:5173 in the address bar.

Look in the my-react-app directory, and you will find a src folder. Inside the src folder there is a file called App.js, open it and it will look like this:

ExampleGet your own React.js Server
This is the default content of the App.jsx file in the src folder:

App.jsx
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vitejs.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App
Try replacing the entire file content with the code below and save the file.

Example
Replace all the content of the App.jsx file with the code below:

App.jsx
function App() {
  return (
    <div className="App">
      <h1>Hello World!</h1>
    </div>
  );
}

export default App;
See the changes in the browser when you click Save.

Notice that the changes are visible immediately after you save the file, you do not have to reload the browser!

React renders HTML to the web page via a container, and a function called createRoot().

The Container
React uses a container to render HTML in a web page.

Typically, this container is a <div id="root"></div> element in the index.html file.

If you have followed the steps in the previous chapter, you should have a file called index.html in the root directory of your project:

ExampleGet your own React.js Server
The default content of the index.html file:

index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
To better understand the content of the index.html file, let's remove all the code we don't need.

Example
The index.html file should now look like this:

index.html
<!doctype html>
<html lang="en">
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
The file is now stripped from unnecessary code, and we can concentrate on learning React without any disturbing elements.

The createRoot Function
The createRoot function is located in the main.jsx file in the src folder, and is a built-in function that is used to create a root node for a React application.

Example
The default content of the src/main.jsx file:

main.jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
      <App />
    </StrictMode>
  )  
The createRoot() function takes one argument, an HTML element.

The purpose of the function is to define the HTML element where a React component should be displayed.

To better understand the createRoot function, let's remove unnecessary code and write our own "Hello React!" example:

Example
The src/main.jsx file should now look like this:

main.jsx
import { createRoot } from 'react-dom/client'

createRoot(document.getElementById('root')).render(
  <h1>Hello React!</h1>
)

The render Method
Did you notice the render method?
The render method defines what to render in the HTML container.
The result is displayed in the <div id="root"> element.

Example
Display a paragraph inside the "root" element:

main.jsx
import { createRoot } from 'react-dom/client'

createRoot(document.getElementById('root')).render(
  <p>Welcome!</p>
) 

Show React
W3Schools has its own "Show React" tool where we will show the result of the code we explain in the tutorial.
Click the "Run Example" button to see the result:
Example
The same example shown in our "Show React" tool:

main.jsx
import { createRoot } from 'react-dom/client'

createRoot(document.getElementById('root')).render(
  <p>Welcome!</p>
) 

The HTML Code
The HTML code in this tutorial uses JSX which allows you to write HTML tags inside the JavaScript code:
Don't worry if the syntax is unfamiliar, you will learn more about JSX later in this tutorial.
Example
Create a variable that contains HTML code and display it in the "root" node:

main.jsx
import { createRoot } from 'react-dom/client'

const myelement = (
  <table>
    <tr>
      <th>Name</th>
    </tr>
    <tr>
      <td>John</td>
    </tr>
    <tr>
      <td>Elsa</td>
    </tr>
  </table>
);

createRoot(document.getElementById('root')).render(
  myelement
)

The Root Node
The root node is the HTML element where you want to display the result.
It is like a container for content, managed by React.
It does NOT have to be a <div> element and it does NOT have to have the id='root':

Example
The root node can be called whatever you like.
Display the result in the <header id="sandy"> element:

index.htmlmain.jsx
<!doctype html>
<html lang="en">
  <body>
    <header id="sandy"></header>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

Classes
ES6 introduced classes.
A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method.
ExampleGet your own React.js Server
A simple class constructor:

class Car {
  constructor(name) {
    this.brand = name;
  }
}
 The constructor function is called automatically when the object is initialized.

 Method in Classes
You can add your own methods in a class:
Example
Create a method named "present":

class Car {
  constructor(name) {
    this.brand = name;
  }
  
  present() {
    return 'I have a ' + this.brand;
  }
}
const mycar = new Car("Ford");
mycar.present();

Class Inheritance
To create a class inheritance, use the extends keyword.
A class created with a class inheritance inherits all the methods from another class:
Example
Create a class named "Model" which will inherit the methods from the "Car" class:

class Car {
  constructor(name) {
    this.brand = name;
  }

  present() {
    return 'I have a ' + this.brand;
  }
}
class Model extends Car {
  constructor(name, mod) {
    super(name);
    this.model = mod;
  }  
  show() {
      return this.present() + ', it is a ' + this.model
  }
}
const mycar = new Model("Ford", "Mustang");
mycar.show();

The super() method refers to the parent class.
By calling the super() method in the constructor method, we call the parent's constructor method and get access to the parent's properties and methods.

Arrow Functions
Arrow functions allow us to write shorter function syntax:
ExampleGet your own React.js Server
Before:

hello = function() {
  return "Hello World!";
}

It gets shorter! If the function has only one statement, and the statement returns a value, you can remove the brackets and the return keyword:
Example
Arrow Functions Return Value by Default:
hello = () => "Hello World!";

Arrow Functions
Arrow functions allow us to write shorter function syntax:

ExampleGet your own React.js Server
Before:

hello = function() {
  return "Hello World!";
}

The handling of this is also different in arrow functions compared to regular functions.
In short, with arrow functions there is no binding of this.
In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever.
With arrow functions, the this keyword always represents the object that defined the arrow function.
Let us take a look at two examples to understand the difference.
Both examples call a method twice, first when the page loads, and once again when the user clicks a button.
The first example uses a regular function, and the second example uses an arrow function.
The result shows that the first example returns two different objects (window and button), and the second example returns the Header object twice.
Example
With a regular function, this represents the object that called the function:

class Header {
  constructor() {
    this.color = "Red";
  }

//Regular function:
  changeColor = function() {
    document.getElementById("demo").innerHTML += this;
  }
}

const myheader = new Header();

//The window object calls the function:
window.addEventListener("load", myheader.changeColor);

//A button object calls the function:
document.getElementById("btn").addEventListener("click", myheader.changeColor

Variables
Before ES6 there was only one way of defining your variables: with the var keyword. If you did not define them, they would be assigned to the global object. Unless you were in strict mode, then you would get an error if your variables were undefined.
Now, with ES6, there are three ways of defining your variables: var, let, and const.
ExampleGet your own React.js Server
var
var x = 5.6;
If you use var outside of a function, it belongs to the global scope.
If you use var inside of a function, it belongs to that function.
If you use var inside of a block, i.e. a for loop, the variable is still available outside of that block.
var has a function scope, not a block scope.

The keyword const is a bit misleading.
It does not define a constant value. It defines a constant reference to a value.
Because of this you can NOT:
Reassign a constant value
Reassign a constant array
Reassign a constant object
But you CAN:
Change the elements of constant array
Change the properties of constant object

The map() Method
The map() method creates a new array with the results of calling a function for every array element.
ExampleGet your own React.js Server
Multiply each number by 2:
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(x => x * 2);
map() in React
The map() method is commonly used in React to render lists of elements:
Example
const fruitlist = ['apple', 'banana', 'cherry'];
function MyList() {
  return (
    <ul>
      {fruitlist.map(fruit => 
        <li key={fruit}>{fruit}</li>
      )}
    </ul>
  );
}

Note: When using map() in React to create list items, each item needs a unique key prop.

map() with Objects
You can also use map() with arrays of objects:
Example
const users = [
  { id: 1, name: 'John', age: 30 },
  { id: 2, name: 'Jane', age: 25 },
  { id: 3, name: 'Bob', age: 35 }
];

function UserList() {
  return (
    <ul>
      {users.map(user => 
        <li key={user.id}>
          {user.name} is {user.age} years old
        </li>
      )}
    </ul>
  );
}

map() Parameters
The map() method takes three parameters:
currentValue - The current element being processed
index - The index of the current element (optional)
array - The array that map was called upon (optional)
Example
const fruitlist = ['apple', 'banana', 'cherry'];

function App() {
  return (
    <ul>
      {fruitlist.map((fruit, index, array) => {
        return (
          <li key={fruit}>
            Number: {fruit}, Index: {index}, Array: {array}
          </li>
        );
      })}
    </ul>
  );
}

Destructuring in React
Destructuring is a JavaScript feature that allows you to extract values from objects or arrays into distinct variables. In React, it's commonly used with props, hooks, and state management.

Note: Destructuring makes React code cleaner and more readable by reducing repetitive object and array access.

Destructing Arrays
Here is the old way of assigning array items to a variable:
ExampleGet your own React.js Server
Before:
const vehicles = ['mustang', 'f-150', 'expedition'];
// old way
const car = vehicles[0];
const truck = vehicles[1];
const suv = vehicles[2];
//You can now access each variable separately:
document.getElementById('demo').innerHTML = truck;

Destructuring Objects
You can use destructuring to extract the values from an object:
Example
Unpack the values from an object:
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50
};
// Destructuring
let {firstName, lastName, age} = person;
//You can now access each variable separately:
document.getElementById("demo").innerHTML = firstName;

Destructuring in React Components
Destructuring is particularly useful in React for working with props, hooks, and API responses. It helps make your code more concise and easier to read.

Props Destructuring
When a component receives props, you can use destructuring to extract the values you need.
Check out the difference between using and not using destructuring:
//Using destructuring:
function Greeting({ name, age }) {
  return <h1>Hello, {name}! You are {age} years old.</h1>;
}
//NOT using destructuring:
function Greeting(props) {
  return <h1>Hello, {props.name}! You are {props.age} years old.</h1>;
}

useState Hook Destructuring
When a component uses the useState hook, we use destructuring to extract the values from it.
Example
Using destructuring to extract values from useState:
import { createRoot, useState } from 'react-dom/client'
function Counter() {
  // Destructuring the array returned by useState
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
createRoot(document.getElementById('root')).render(
  <Counter />
);

Spread Operator
The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object into another array or object.
ExampleGet your own React.js Server
const numbersOne = [1, 2, 3];
const numbersTwo = [4, 5, 6];
const numbersCombined = [...numbersOne, ...numbersTwo];

Modules
JavaScript modules allow you to break up your code into separate files.
This makes it easier to maintain the code-base.
ES Modules rely on the import and export statements.

Export
You can export a function or variable from any file.
Let us create a file named person.js, and fill it with the things we want to export.
There are two types of exports: Named and Default.
Named Exports
You can create named exports two ways:
ExampleGet your own React.js Server
In-line individually:
person.js
export const name = "Tobias"
export const age = 18

Default Exports
Let us create another file, named message.js, and use it for demonstrating default export.
You can only have one default export in a file.

Example
Insert the following code into the newly created file:
message.js
const message = () => {
  const name = "Tobias";
  const age = 18;
  return name + ' is ' + age + 'years old.';
};
export default message;

Import
You can import modules into a file in two ways, based on if they are named exports or default exports.
Named exports must be destructured using curly braces. Default exports do not.
Example
Import named exports from the file person.js:
import { name, age } from "./person.js";

Ternary Operator
The ternary operator is a simplified conditional operator like if / else.
Syntax: condition ? <expression if true> : <expression if false>
Here is an example using if / else:
ExampleGet your own React.js Server
Before:
if (authenticated) {
  renderApp();
} else {
  renderLogin();
}

Template Strings
Template strings allow you to write strings that span multiple lines and include embedded expressions:
ExampleGet your own React.js Server
Before:
const name = "John";
const age = 30;
const message = "Hello, " + name + "!\n" + 
"You are " + age + " years old.";

Template strings use backticks (`) instead of quotes and can include:
Multiple lines without \n
Expressions inside ${}
Quotes without escaping
Example
Multi-line Strings:
const html = `
  <div>
    <h1>Title</h1>
    <p>Paragraph</p>
  </div>
`;

Expression Interpolation
You can include any valid JavaScript expression inside ${} in a template string:
Example
Insert variables inside template strings:
let firstName = "John";
let lastName = "Doe";
let text = `Welcome ${firstName}, ${lastName}!`

Tagged Templates
You can also use template strings with a function (called a tag) to modify the output.
Note: Tagged templates are an advanced feature. You might not need them in most cases.
The function takes the text and the expression(s) as arguments.
Look at the example below:
Example
Tagged Template:
function highlight(strings, fname) {
  let x = fname.toUpperCase();
  return strings[0] + x + strings[1];
}
let name = "John";
let text = highlight`Hello ${name}, how are you?`;

What is JSX?
JSX stands for JavaScript XML.
JSX allows us to write HTML in React.
JSX makes it easier to write and add HTML in React.
Coding JSX
JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement()  and/or appendChild() methods.
JSX converts HTML tags into react elements.
You are not required to use JSX, but JSX makes it easier to write React applications.
Here are two examples. The first uses JSX and the second does not:
Example 1Get your own React.js Server
JSX:
main.jsx
const myElement = <h1>I Love JSX!</h1>;
createRoot(document.getElementById('root')).render(
  myElement
);

Expressions in JSX
With JSX you can write expressions inside curly braces { }.
The expression can be a React variable, or property, or any other valid JavaScript expression. JSX will execute the expression and return the result:
Example
Execute the expression 5 + 5:
main.jsx
const myElement = <h1>React is {5 + 5} times better with JSX</h1>;
Inserting a Large Block of HTML
To write HTML on multiple lines, put the HTML inside parentheses:
Example
Create a list with three list items:
main.jsx
const myElement = (
  <ul>
    <li>Apples</li>
    <li>Bananas</li>
    <li>Cherries</li>
  </ul>
);

One Top Level Element
The HTML code must be wrapped in ONE top level element.
So if you like to write two paragraphs, you must put them inside a parent element, like a div element.
Example
Wrap two paragraphs inside one DIV element:
main.jsx
const myElement = (
  <div>
    <p>I am a paragraph.</p>
    <p>I am a paragraph too.</p>
  </div>
);

JSX will throw an error if the HTML is not correct, or if the HTML misses a parent element.
Alternatively, you can use a "fragment" to wrap multiple lines. This will prevent unnecessarily adding extra nodes to the DOM.
A fragment looks like an empty HTML tag: <></>.
Example
Wrap two paragraphs inside a fragment:
main.jsx
const myElement = (
  <>
    <p>I am a paragraph.</p>
    <p>I am a paragraph too.</p>
  </>
);
Elements Must be Closed
JSX follows XML rules, and therefore HTML elements must be properly closed.
Example
Close empty elements with />
main.jsx
const myElement = <input type="text" />;

Attribute class = className
The class attribute is a much used attribute in HTML, but since JSX is rendered as JavaScript, and the class keyword is a reserved word in JavaScript, you are not allowed to use it in JSX.
Use attribute className instead.
JSX solved this by using className instead. When JSX is rendered, it translates className attributes into class attributes.
Example
Use attribute className instead of class in JSX:
main.jsx
const myElement = <h1 className="myclass">Hello World</h1>;

Comments in JSX
Comments in JSX are written with {/* */}
Example
Comments in JSX:
main.jsx
const myElement = <h1>Hello {/* Wonderful */} World </h1>;

JSX in React Components
React uses components to build UIs. Components are independent and reusable bits of code.
React components are like JavaScript functions, and return HTML.
JSX works perfect inside React components
Example
JSX in Components:
main.jsx
function Car() {
  return (
    <>
      <h2>My Car</h2>
      <p>It is a Ford Mustang.</p>
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <Car />
)

React JSX Expressions
One of the most powerful features of JSX is the ability to embed JavaScript expressions directly within your markup.
Expressions
You can insert any valid JavaScript expression inside JSX by wrapping it in curly braces { }.
React will evaluate the expression and render the result in the DOM.
ExampleGet your own React.js Server
Execute the expression 218 * 1.36:
function Car() {
  return (
    <>
      <h1>My car</h1>
      <p>It has {218 * 1.36} horsepower</p>
    </>
  );
}

Variables
Variables are also valid expressions. Insert variables in JSX by wrapping it in curly braces { }.
Example
Use a variable inside JSX:
function Car() {
  const hp = 218 * 1.36;
  return (
    <>
      <h1>My car</h1>
      <p>It has {hp} horsepower</p>
    </>
  );
}

Function Calls
Function calls are valid expressions. Insert function calls in JSX by wrapping it in curly braces { }.
Example
Use a function inside JSX:
function kwtohp(kw) {
  return kw * 1.36;
}
function Car() {
  return (
    <>
      <h1>My car</h1>
      <p>It has {kwtohp(218)} horsepower</p>
    </>
  );
}

Object Properties
Access object properties within JSX:
Example
Refer to an object property inside JSX:
function Car() {
  const myobj = {
    name: "Fiat",
    model: "500",
    color: "white"
  };
  return (
    <>
      <h1>My car is a {myobj.color} {myobj.name} {myobj.model}</h1>
    </>
  );
}

React JSX Attributes
JSX allows you to insert attributes into HTML elements, but there are a few important differences.
class = className
The class attribute is a much used attribute in HTML, but since JSX is rendered as JavaScript, and the class keyword is a reserved word in JavaScript, you are not allowed to use it in JSX.
JSX solved this by using className instead. When JSX is rendered, it translates className attributes into class attributes.
ExampleGet your own React.js Server
Use attribute className instead of class in JSX:
function Car() {
  return (
    <h1 className="myclass">Hello World</h1>
  );
}

Expressions as Attributes
You can also use JavaScript expressions as attribute values. This is very useful for dynamic attributes.
Example
Use JavaScript expressions as attribute values:
function Car() {
  const x = "myclass";
  return (
    <h1 className={x}>Hello World</h1>
  );
}

Note that the attribute value is not wrapped in quotes, this is important when using expressions (JavaScript variables) as attribute values. If you use quotes, JSX will treat it as a string literals and not a JavaScript expression.

camelCase Event Attributes
Event attributes in JSX are written in camelCase.
Example
Use camelCase for event attributes:
function Car() {
  const myfunc = () => {
    alert('Hello World');
  };
  return (
    <button onClick={myfunc}>Click me</button>
  );
}

Boolean Attributes
If you pass no value for an attribute, JSX treats it as true. To pass false, you must specify it as an expression.
Example
Boolean true in JSX, this will make the button disabled:
<button onClick={myfunc} disabled>Click me</button>

The style Attribute
The style attribute in JSX only accepts a JavaScript object with camelCased CSS property names, rather than a CSS string (as in HTML).
Example
Use the style attribute:
function Car() {
  const mystyles = {
    color: "red",
    fontSize: "20px",
    backgroundColor: "lightyellow",
  };
  return (
    <>
      <h1 style={mystyles}>My car</h1>
    </>
  );
}

Conditions - if statements
React supports if statements, but not inside JSX.
To be able to use conditional statements in JSX, you should put the if statements outside of the JSX, or you could use a ternary expression instead:
Option 1:
Write if statements outside of the JSX code:
ExampleGet your own React.js Server
Write "Banana" if x is less than 10, otherwise "Apple":
function Fruit() {
  const x = 5;
  let y = "Apple";
  if (x < 10) {
    y = "Banana";
  }
  return (
    <h1>{y}</h1>
  );
}

React Components
Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, but work in isolation and return HTML.
Components come in two types, Class components and Function components, in this tutorial we will concentrate on Function components.
In older React code bases, you may find Class components primarily used.
It is now suggested to use Function components along with Hooks, instead of Class components.
Class components are still supported, check the Class components section for more information.
Create Your First Component
When creating a React component, the component's name MUST start with an upper case letter.
React components returns HTML code.
ExampleGet your own React.js Server
Create a Function component called Car
function Car() {
  return (
    <h2>Hi, I am a Car!</h2>
  );
}

Rendering a Component
Now your React application has a component called Car, which returns an <h2> element.
To use this component in your application, refer to it like this: <Car />
Example
Display the Car component in the "root" element:
createRoot(document.getElementById('root')).render(
  <Car />
)

Props
Arguments can be passed into a component as props, which stands for properties.
You send the arguments into the component as HTML attributes.
You will learn more about props in our React Props chapter.
Example
Use an attribute to pass a color to the Car component, and use it in the render function:
function Car(props) {
  return (
    <h2>I am a {props.color} Car!</h2>
  );
}
createRoot(document.getElementById('root')).render(
  <Car color="red"/>
);

Components in Components
We can refer to components inside other components:
Example
Use the Car component inside the Garage component:
function Car() {
  return (
    <h2>I am a Car!</h2>
  );
}
function Garage() {
  return (
    <>
      <h1>Who lives in my Garage?</h1>
      <Car />
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <Garage />
);

Rendering a Component Twice
We can render a component multiple times:
Example
Use the Car component twice inside the Garage component:
function Car() {
  return (
    <h2>I am a Car!</h2>
  );
}
function Garage() {
  return (
    <>
      <h1>Who lives in my Garage?</h1>
      <Car />
      <Car />
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <Garage />
);

Components in Files
React is all about re-using code, and it can be a good idea to split your components into separate files.
To do that, create a new file in the src folder with a .jsx file extension and put the code inside it:
Note that the filename must start with an uppercase character.
Example
This is the new file, we named it Vehicle.jsx:
Vehicle.jsx
function Car() {
  return (
    <h2>Hi, I am a Car!</h2>
  );
}
export default Car;

React Components
Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, but work in isolation and return HTML via a render function.
Components come in two types, Class components and Function components, in this chapter you will learn about Class components.
Create a Class Component
When creating a React component, the component's name must start with an upper case letter.
The component has to include the extends React.Component statement, this statement creates an inheritance to React.Component, and gives your component access to React.Component's functions.
The component also requires a render() method, this method returns HTML.
ExampleGet your own React.js Server
Create a Class component called Car
class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}

Component Constructor
If there is a constructor() function in your component, this function will be called when the component gets initiated.
The constructor function is where you initiate the component's properties.
In React, component properties should be kept in an object called state.
You will learn more about state later in this tutorial.
The constructor function is also where you honor the inheritance of the parent component by including the super() statement, which executes the parent component's constructor function, and your component has access to all the functions of the parent component (React.Component).
Example
Create a constructor function in the Car component, and add a color property:
class Car extends React.Component {
  constructor() {
    super();
    this.state = {color: "red"};
  }
  render() {
    return <h2>I am a Car!</h2>;
  }
}

Props
Another way of handling component properties is by using props.
Props are like function arguments, and you send them into the component as attributes.
You will learn more about props in the next chapter.
Example
Use an attribute to pass a color to the Car component, and use it in the render function:
class Car extends React.Component {
  render() {
    return <h2>I am a {this.props.color} Car!</h2>;
  }
}
createRoot(document.getElementById('root')).render(
  <Car color="red"/>
);

Props in the Constructor
If your component has a constructor function, the props should always be passed to the constructor and also to the React.Component via the super() method.
Example
class Car extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <h2>I am a {this.props.model}!</h2>;
  }
}
createRoot(document.getElementById('root')).render(
  <Car model="Mustang"/>
);

React Class Component State
React Class components have a built-in state object.
You might have noticed that we used state earlier in the component constructor section.
The state object is where you store property values that belongs to the component.
When the state object changes, the component re-renders.

Creating the state Object
The state object is initialized in the constructor:
Example
Specify the state object in the constructor method:
class Car extends React.Component {
  constructor(props) {
    super(props);
  this.state = {brand: "Ford"};
  }
  render() {
    return (
      <div>
        <h1>My Car</h1>
      </div>
    );
  }
}
The state object can contain as many properties as you like:

Example
Specify all the properties your component need:

class Car extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      brand: "Ford",
      model: "Mustang",
      color: "red",
      year: 1964
    };
  }
  render() {
    return (
      <div>
        <h1>My Car</h1>
      </div>
    );
  }
}
Using the state Object
Refer to the state object anywhere in the component by using the this.state.propertyname syntax:
Example:
Refer to the state object in the render() method:
class Car extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      brand: "Ford",
      model: "Mustang",
      color: "red",
      year: 1964
    };
  }
  render() {
    return (
      <div>
        <h1>My {this.state.brand}</h1>
        <p>
          It is a {this.state.color}
          {this.state.model}
          from {this.state.year}.
        </p>
      </div>
    );
  }
}

Changing the state Object
To change a value in the state object, use the this.setState() method.
When a value in the state object changes, the component will re-render, meaning that the output will change according to the new value(s).
Example:
Add a button with an onClick event that will change the color property:
class Car extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      brand: "Ford",
      model: "Mustang",
      color: "red",
      year: 1964
    };
  }
  changeColor = () => {
    this.setState({color: "blue"});
  }
  render() {
    return (
      <div>
        <h1>My {this.state.brand}</h1>
        <p>
          It is a {this.state.color}
          {this.state.model}
          from {this.state.year}.
        </p>
        <button
          type="button"
          onClick={this.changeColor}
        >Change color</button>
      </div>
    );
  }
}
Always use the setState() method to change the state object, it will ensure that the component knows its been updated and calls the render() method (and all the other lifecycle methods).

Lifecycle of Components
Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.
The three phases are: Mounting, Updating, and Unmounting.

Mounting
Mounting means putting elements into the DOM.
React has four built-in methods that gets called, in this order, when mounting a component:

constructor()
getDerivedStateFromProps()
render()
componentDidMount()
The render() method is required and will always be called, the others are optional and will be called if you define them.
constructor
The constructor() method is called before anything else, when the component is initiated, and it is the natural place to set up the initial state and other initial values.
The constructor() method is called with the props, as arguments, and you should always start by calling the super(props) before anything else, this will initiate the parent's constructor method and allows the component to inherit methods from its parent (React.Component).
Example:
The constructor method is called, by React, every time you make a component:
class Header extends React.Component 
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  render() {
    return (
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header />
);

getDerivedStateFromProps
The getDerivedStateFromProps() method is called right before rendering the element(s) in the DOM.
This is the natural place to set the state object based on the initial props.
It takes state as an argument, and returns an object with changes to the state.
The example below starts with the favorite color being "red", but the getDerivedStateFromProps() method updates the favorite color based on the favcol attribute:
Example:
The getDerivedStateFromProps method is called right before the render method:
class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  static getDerivedStateFromProps(props, state) {
    return {favoritecolor: props.favcol };
  }
  render() {
    return (
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header favcol="yellow"/>
);

render
The render() method is required, and is the method that actually outputs the HTML to the DOM.

Example:
A simple component with a simple render() method:

class Header extends React.Component {
  render() {
    return (
      <h1>This is the content of the Header component</h1>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header />
);

componentDidMount
The componentDidMount() method is called after the component is rendered.
This is where you run statements that requires that the component is already placed in the DOM.
Example:
At first my favorite color is red, but give me a second, and it is yellow instead:
class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  componentDidMount() {
    setTimeout(() => {
      this.setState({favoritecolor: "yellow"})
    }, 1000)
  }
  render() {
    return (
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header />
);

Updating
The next phase in the lifecycle is when a component is updated.
A component is updated whenever there is a change in the component's state or props.
React has five built-in methods that gets called, in this order, when a component is updated:

getDerivedStateFromProps()
shouldComponentUpdate()
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
The render() method is required and will always be called, the others are optional and will be called if you define them.

getDerivedStateFromProps
Also at updates the getDerivedStateFromProps method is called. This is the first method that is called when a component gets updated.
This is still the natural place to set the state object based on the initial props.
The example below has a button that changes the favorite color to blue, but since the getDerivedStateFromProps() method is called, which updates the state with the color from the favcol attribute, the favorite color is still rendered as yellow:

Example:
If the component gets updated, the getDerivedStateFromProps() method is called:

class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  static getDerivedStateFromProps(props, state) {
    return {favoritecolor: props.favcol };
  }
  changeColor = () => {
    this.setState({favoritecolor: "blue"});
  }
  render() {
    return (
      <div>
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
      <button type="button" onClick={this.changeColor}>Change color</button>
      </div>
    );
  }
}
createRoot(document.getElementById('root')).render(
  <Header favcol="yellow" />
);

shouldComponentUpdate
In the shouldComponentUpdate() method you can return a Boolean value that specifies whether React should continue with the rendering or not.
The default value is true.
The example below shows what happens when the shouldComponentUpdate() method returns false:

Example:
Stop the component from rendering at any update:

class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  shouldComponentUpdate() {
    return false;
  }
  changeColor = () => {
    this.setState({favoritecolor: "blue"});
  }
  render() {
    return (
      <div>
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
      <button type="button" onClick={this.changeColor}>Change color</button>
      </div>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header />
);

Example:
Same example as above, but this time the shouldComponentUpdate() method returns true instead:

class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  shouldComponentUpdate() {
    return true;
  }
  changeColor = () => {
    this.setState({favoritecolor: "blue"});
  }
  render() {
    return (
      <div>
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
      <button type="button" onClick={this.changeColor}>Change color</button>
      </div>
    );
  }
}

createRoot(document.getElementById('root')).render(
  <Header />
);

render
The render() method is of course called when a component gets updated, it has to re-render the HTML to the DOM, with the new changes.
The example below has a button that changes the favorite color to blue:
Example:
Click the button to make a change in the component's state:
class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  changeColor = () => {
    this.setState({favoritecolor: "blue"});
  }
  render() {
    return (
      <div>
      <h1>My Favorite Color is {this.state.favoritecolor}</h1>
      <button type="button" onClick={this.changeColor}>Change color</button>
      </div>
    );
  }
}
createRoot(document.getElementById('root')).render(
  <Header />
);

getSnapshotBeforeUpdate
In the getSnapshotBeforeUpdate() method you have access to the props and state before the update, meaning that even after the update, you can check what the values were before the update.
If the getSnapshotBeforeUpdate() method is present, you should also include the componentDidUpdate() method, otherwise you will get an error.
The example below might seem complicated, but all it does is this:
When the component is mounting it is rendered with the favorite color "red".
When the component has been mounted, a timer changes the state, and after one second, the favorite color becomes "yellow".
This action triggers the update phase, and since this component has a getSnapshotBeforeUpdate() method, this method is executed, and writes a message to the empty DIV1 element.
Then the componentDidUpdate() method is executed and writes a message in the empty DIV2 element:

Example:
Use the getSnapshotBeforeUpdate() method to find out what the state object looked like before the update:
class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {favoritecolor: "red"};
  }
  componentDidMount() {
    setTimeout(() => {
      this.setState({favoritecolor: "yellow"})
    }, 1000)
  }
  getSnapshotBeforeUpdate(prevProps, prevState) {
    document.getElementById("div1").innerHTML =
    "Before the update, the favorite was " + prevState.favoritecolor;
  }
  componentDidUpdate() {
    document.getElementById("div2").innerHTML =
    "The updated favorite is " + this.state.favoritecolor;
  }
  render() {
    return (
      <div>
        <h1>My Favorite Color is {this.state.favoritecolor}</h1>
        <div id="div1"></div>
        <div id="div2"></div>
      </div>
    );
  }
}
createRoot(document.getElementById('root')).render(
  <Header />
);

React Props
React Props are like function arguments in JavaScript and attributes in HTML.
To send props into a component, use the same syntax as HTML attributes:
ExampleGet your own React.js Server
Add a brand attribute to the Car element:
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" />
);

Pass Multiple Properties
You can send as many properties as you want.
Every attribute is sent to the Car component as object properties.
Example
Send multiple properties to the Car component:
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" model="Mustang" color="red" />
);
All properties are received in the Car component inside the props object:

Different Data Types
React props can be of any data type, including variables, numbers, strings, objects, arrays, and more.
Strings can be sent inside quotes as in the examples above, but numbers, variables, and objects need to be sent inside curly brackets.
Example
Numbers has to be sent inside curly brackets to be treated as numbers:
createRoot(document.getElementById('root')).render(
  <Car year={1969} />
);

Object Props
The component treats objects like objects, and you can use the dot notation to access the properties.
Example
Use the dot notation to access object properties:
function Car(props) {
  return (
    <>
      <h2>My {props.carinfo.name} {props.carinfo.model}!</h2>
      <p>It is {props.carinfo.color} and it is from {props.carinfo.year}!</p>
    </>
  );
}
const carInfo = {
  name: "Ford",
  model: "Mustang",
  color: "red",
  year: 1969
};
createRoot(document.getElementById('root')).render(
  <Car carinfo={carInfo} />
);

Array Props
Array props can be accessed using the indexes.
Example
Use the indexes to access array properties:
function Car(props) {
  return (
    <h2>My car is a {props.carinfo[0]} {props.carinfo[1]}!</h2>
  );
}
const carInfo = ["Ford", "Mustang"];
createRoot(document.getElementById('root')).render(
  <Car carinfo={carInfo} />
);

Pass Props from Component to Component
Attributes are also how you pass data from one component to another, as parameters.
Example
Send the brand attribute from the Garage component to the Car component:
function Car(props) {
  return (
    <h2>I am a {props.brand}!</h2>
  );
}
function Garage() {
  return (
    <>
      <h1>Who lives in my garage?</h1>
      <Car brand="Ford" />
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <Garage />
);

Destructuring Props
You can limit the properties a component receives by using destructuring.
ExampleGet your own React.js Server
The component knows it only need the color property, so in the function definition, it only specifies that:
function Car({color}) {
  return (
    <h2>My car is {color}!</h2>
  );
}
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" model="Mustang" color="red" year={1969} />
);

Destructuring ...rest
When you don't know how many properties you will receive, you can use the ...rest operator.
Meaning: you can specify the properties you need, and the rest will be stored in an object.
Example
The component specifies the color and the brand, but the rest is stored in an object like this:
{ model: "Mustang", year: 1969 }.
function Car({color, brand, ...rest}) {
  return (
    <h2>My {brand} {rest.model} is {color}!</h2>
  );
}
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" model="Mustang" color="red" year={1969} />
);

Default Values
With Destructuring, you can set default values for props.
If a property has no value, the default value will be used.
Example
Set the default color value to "blue":
function Car({color = "blue", brand}) {
  return (
    <h2>My {color} {brand}!</h2>
  );
}
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" />
);

Props Children
In React, you can send the content between the opening and closing tags of a component, to another component.
This can be accessed in the other component using the props.children property.
ExampleGet your own React.js Server
From the Parent component, send the content between the opening and closing tags of the Son and Daughter components:
function Son(props) {
  return (
    <div style={{background: 'lightgreen'}}>
      <h2>Son</h2>
      <div>{props.children}</div>
    </div>
  );
}
function Daughter(props) {
  const {brand, model} = props;
  return (
    <div style={{background: 'lightblue'}}>
      <h2>Daughter</h2>
      <div>{props.children}</div>
    </div>
  );
}
function Parent() {
  return (
    <div>
      <h1>My two Children</h1>
      <Son>
        <p>
          This was written in the Parent component,
          but displayed as a part of the Son component
        </p>
      </Son>
      <Daughter>
        <p>
          This was written in the Parent component,
          but displayed as a part of the Daughter component
        </p>
      </Daughter>
    </div>
  );
}
createRoot(document.getElementById('root')).render(
  <Parent />
);

React Events
Just like HTML DOM events, React can perform actions based on user events.
React has the same events as HTML: click, change, mouseover etc.

Adding Events
React events are written in camelCase syntax:
onClick instead of onclick.
React event handlers are written inside curly braces:
onClick={shoot}  instead of onclick="shoot()".

React:Get your own React.js Server
<button onClick={shoot}>Take the Shot!</button>
HTML:
<button onclick="shoot()">Take the Shot!</button>
Example:
Put the shoot function inside the Football component:
function Football() {
  const shoot = () => {
    alert("Great Shot!");
  }
  return (
    <button onClick={shoot}>Take the shot!</button>
  );
}
createRoot(document.getElementById('root')).render(
  <Football />
);

REMOVE ADS

Passing Arguments
To pass an argument to an event handler, use an arrow function.
Example:
Send "Goal!" as a parameter to the shoot function, using arrow function:
function Football() {
  const shoot = (a) => {
    alert(a);
  }
  return (
    <button onClick={() => shoot("Goal!")}>Take the shot!</button>
  );
}
createRoot(document.getElementById('root')).render(
  <Football />
);

React Event Object
Event handlers have access to the React event that triggered the function.
In our example the event is the "click" event.
Example:
Arrow Function: Sending the event object manually:
function Football() {
  const shoot = (a, b) => {
    alert(b.type);
    /*
    'b' represents the React event that triggered the function,
    in this case the 'click' event
    */
  }
  return (
    <button onClick={(event) => shoot("Goal!", event)}>Take the shot!</button>
  );
}
createRoot(document.getElementById('root')).render(
  <Football />
);

if Statement
We can use the if JavaScript operator to decide which component to render.
Example:Get your own React.js Server
We'll use these two components:
function MissedGoal() {
  return <h1>MISSED!</h1>;
}
function MadeGoal() {
  return <h1>Goal!</h1>;
}

Logical && Operator
Another way to conditionally render a React component is by using the && operator.
In the example below, the heading will only be rendered if the props.brand property is not empty:
Example:
The right side of && will only be rendered if the left side is true:
function Car(props) {
  return (
    <>
      {props.brand && <h1>My car is a {props.brand}!</h1>}
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <Car brand="Ford" />
);
If props.brand evaluates to true, the expression after && will render.

Ternary Operator
Another way to conditionally render elements is by using a ternary operator.
condition ? true : false

React Lists
In React, you will render lists with some type of loop.
The JavaScript map() array method is generally the preferred method.
If you need a refresher on the map() method, check out the ES6 Array map() section.
Example:Get your own React.js Server
Let's create a simple list using the map() method:
function MyCars() {
  const cars = ['Ford', 'BMW', 'Audi'];
  return (
    <>
      <h1>My Cars:</h1>
      <ul>
        {cars.map((car) => <li>I am a { car }</li>)}
      </ul>
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <MyCars />
);

Keys in React Lists
Keys allow React to keep track of elements. This way, if an item is updated or removed, only that item will be re-rendered instead of the entire list.
Keys must be unique among siblings, but they don't have to be unique across the entire application.
Generally, the key should be a unique ID assigned to each item. As a last resort, you can use the array index as a key.
Example:
Here the example from above, with keys:
function MyCars() {
  const cars = [
    {id: 1001, brand: 'Ford'},
    {id: 1002, brand: 'BMW'},
    {id: 1003, brand: 'Audi'}
  ];
  return (
    <>
      <h1>My Cars:</h1>
      <ul>
        {cars.map((car) => <li key={car.id}>I am a { car.brand }</li>)}
      </ul>
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <MyCars />
);

Using Array Index as Keys
While it's possible to use the array index as a key, it's not recommended unless:
The list is static (won't change)
The list will never be reordered or filtered
The items in the list have no IDs
Example:
Using array indexes as keys (not recommended for dynamic lists):
function MyCars() {
  const cars = ['Ford', 'BMW', 'Audi'];
  return (
    <>
      <h1>My Cars:</h1>
      <ul>
        {cars.map((car, index) => <li key={index}>I am a { car }</li>)}
      </ul>
    </>
  );
}
createRoot(document.getElementById('root')).render(
  <MyCars />
);

Adding Forms in React
You add a form with React like any other element:
Example:Get your own React.js Server
Add a form that allows users to enter their name:
function MyForm() {
  return (
    <form>
      <label>Enter your name:
        <input type="text" />
      </label>
    </form>
  )
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);

This will work as normal, the form will submit and the page will refresh.
But this is generally not what we want to happen in React.
We want to prevent this default behavior and let React control the form.

HTML Forms vs. React Forms
In React, form elements like <input>, <textarea>, and <select> work a bit differently from traditional HTML.
In standard HTML, form elements maintain their own value based on user input.
For example, an <input type="text"> field keeps track of its own value in the HTML DOM.
In React, the value of the form element is kept in the component's state property and updated only with the setState() function.
In other words; React provides a way to manage form data through component state, leading to what are known as "controlled components."

Controlled Components
In a controlled component, form data is handled by the React component.
The value of the input element is driven by the React state, and any changes to that value are managed through event handlers that update the state.
When the data is handled by the components, all the data is stored in the component state.
We can use the useState Hook to keep track of each input value and provide a "single source of truth" for the entire application.
See the React Hooks section for more information on Hooks.

Example:
Use the useState Hook to manage the input:
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
function MyForm() {
  const [name, setName] = useState("");

  function handleChange(e) {
    setName(e.target.value);
  }
  return (
    <form>
      <label>Enter your name:
        <input
          type="text" 
          value={name}
          onChange={handleChange}
        />
      </label>
      <p>Current value: {name}</p>
    </form>
  )
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);

Initial Values
To add an initial value to the input field in the example above, add a value to the useState object:
Example:
Use initial value for name:
function MyForm() {
  const [name, setName] = useState("John");

Submitting Forms
You can control the submit action by adding an event handler in the onSubmit attribute for the <form>:
Example:Get your own React.js Server
Add a submit button and an event handler in the onSubmit attribute:
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
function MyForm() {
  const [name, setName] = useState("");

  function handleChange(e) {
    setName(e.target.value);
  }
  function handleSubmit(e) {
    e.preventDefault();
    alert(name);
  }
  return (
    <form onSubmit={handleSubmit}>
      <label>Enter your name:
        <input
          type="text" 
          value={name}
          onChange={handleChange}
        />
      </label>
      <input type="submit" />
    </form>
  )
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);

Textarea
The textarea element in React is slightly different from ordinary HTML.
In HTML the value of a textarea is the text between the start tag <textarea> and the end tag </textarea>.
<textarea>
  Content of the textarea.
</textarea>

Select
A drop down list, or a select box, in React is also a bit different from HTML.
In HTML, the selected value in the drop down list is defined with the selected attribute:
HTML:Get your own React.js Server
<select>
  <option value="Ford">Ford</option>
  <option value="Volvo" selected>Volvo</option>
  <option value="Fiat">Fiat</option>
</select>

Handling Multiple Inputs
When you have multiple controlled input fields in a form, you can manage their state either by:
1. Using a separate useState call for each input.
2. Using a single useState call with an object to hold all form field values.
We will use the second approach, as it is more common for forms.
Make sure each input field has a unique name attribute.
Also, when initializing the state, use an object instead of a string. If the input fields have no initial value, use an empty object.
Example:Get your own React.js Server
Use the useState Hook to manage the input:
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
function MyForm() {
  const [inputs, setInputs] = useState({});
  const handleChange = (e) => {
    const name = e.target.name;
    const value = e.target.value;
    setInputs(values => ({...values, [name]: value}))
  }
  return (
    <form>
      <label>First name:
      <input 
        type="text" 
        name="firstname" 
        value={inputs.firstname} 
        onChange={handleChange}
      />
      </label>
      <label>Last name:
        <input 
          type="text" 
          name="lastname" 
          value={inputs.lastname} 
          onChange={handleChange}
        />
      </label>
      <p>Current values: {inputs.firstname} {inputs.lastname}</p>
    </form>
  )
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);

Initial Values
To add initial values to the input fields in the example above, add the proper keys and values to the useState object:
Example:
Use initial values for firstname and lastname:
function MyForm() {
  const [inputs, setInputs] = useState({
    firstname: 'John',
    lastname: 'Doe'
  });

Checkbox
For checkboxes, use the checked attribute instead of value to control its state.
We'll use the useState Hook to manage the value of the textarea:
In the handleChange function, use the e.target.type property check if the current input is a checkbox or not.
Example:Get your own React.js Server
React uses the checked attribute to control the checkbox:
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
function MyForm() {
  const [inputs, setInputs] = useState({});
  const handleChange = (e) => {
    const target = e.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;
    setInputs(values => ({...values, [name]: value}))
  }
  const handleSubmit = (event) => {
    let fillings = '';
    if (inputs.tomato) fillings += 'tomato';
    if (inputs.onion) {
      if (inputs.tomato) fillings += ' and ';
      fillings += 'onion';
    }
    if (fillings == '') fillings = 'no fillings';
    alert(`${inputs.firstname} wants a burger with ${fillings}`);
    event.preventDefault();
  };
  return (
    <form onSubmit={handleSubmit}>
      <label>My name is:
      <input 
        type="text" 
        name="firstname" 
        value={inputs.firstname} 
        onChange={handleChange}
      />
      </label>
      <p>I want a burger with:</p>
      <label>Tomato:
      <input 
        type="checkbox" 
        name="tomato" 
        checked={inputs.tomato} 
        onChange={handleChange}
      />
      </label>
      <label>Onion:
        <input 
          type="checkbox" 
          name="onion" 
          checked={inputs.onion} 
          onChange={handleChange}
        />
      </label>
      <button type="submit">Submit
    </form>
  )
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);

Initial Values
To add initial values to the input fields in the example above, add the proper keys and values to the useState object:
Example:
Use initial values for the input fields:
function MyForm() {
  const [inputs, setInputs] = useState({
    firstname: 'John',
    tomato: true,
    onion: false
});

Radio
Radio buttons are typically used in groups where only one option can be selected.
All radio buttons in a group should share the same name attribute.
You control radio buttons based on whether the radio button's value matches the selected value in your state.

Example:Get your own React.js Server
React uses the checked attribute to control the radio button:
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
function MyForm() {
  const [selectedFruit, setSelectedFruit] = useState('banana');
  const handleChange = (event) => {
    setSelectedFruit(event.target.value);
  };
  const handleSubmit = (event) => {
    alert(`Your favorite fruit is: ${selectedFruit}`);
    event.preventDefault();
  };
  return (
    <form onSubmit={handleSubmit}>
      <p>Select your favorite fruit:</p>
      <label>
        <input 
          type="radio" 
          name="fruit" 
          value="apple" 
          checked={selectedFruit === 'apple'} 
          onChange={handleChange} 
        /> Apple
      </label>
      <br />
      <label>
        <input 
          type="radio" 
          name="fruit" 
          value="banana" 
          checked={selectedFruit === 'banana'} 
          onChange={handleChange} 
        /> Banana
      </label>
      <br />
      <label>
        <input 
          type="radio" 
          name="fruit" 
          value="cherry" 
          checked={selectedFruit === 'cherry'} 
          onChange={handleChange} 
        /> Cherry
      </label>
      <br />
      <button type="submit">Submit</button>
    </form>
  );
}
createRoot(document.getElementById('root')).render(
  <MyForm />
);
